version "4.0"

class SoulCubeHandler : StaticEventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'Lumberjack':
				if (random[cuberand]() <= 32)
				{
					e.Replacement = "HDSoulCube";
				}
				break;
		}
	}
}

class HDSoulCube : HDWeapon
{
	enum SCProperty
	{
		SCProp_UseOffset,
		SCProp_Frag
	}

	action void A_AddOffset(int ofs)
	{
		invoker.WeaponStatus[SCProp_UseOffset] += ofs;
	}

	override string, double GetPickupSprite() { return "SLCBA3A7", 0.5; }
	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Attack\n"
		..WEPHELP_FIRE.."+"..WEPHELP_FIREMODE.."  Grant spiritual armor\n"
		..WEPHELP_ZOOM.."  Toggle vaccuum mode";
	}
	override double WeaponBulk() { return 80 * Amount; }

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		vector2 bob = hpl.hudbob * 0.3;
		int Offset = WeaponStatus[SCProp_UseOffset];
		bob.y += Offset;
		int BaseYOffset = -220;
		
		sb.DrawImage("SLCBA3A7", (0, BaseYOffset + 68) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER, alpha: 1.0, scale:(2, 2));
		if (WeaponStatus[SCProp_Frag] >= MinFrag)
		{
			sb.DrawString(sb.pSmallFont, "Use us.", (0, BaseYOffset + 120) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GREEN);
		}
		else
		{
			sb.DrawString(sb.pSmallFont, "Not enough frag.", (0, BaseYOffset + 120) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GOLD);
		}

		// [Ace] Spiritual armor.
		int SpiritArmorCount = sb.GetAmount("SpiritualArmour");
		string ProtectionString = "\c[Red]You are not protected.\c-";

		switch (SpiritArmorCount)
		{
			case 1: ProtectionString = "\c[Orange]You are barely protected.\c-"; break;
			case 2: ProtectionString = "\c[Yellow]The spirits guard your soul.\c-"; break;
			case 3: ProtectionString = "\c[Green]Your soul has transcended beyond harm.\c-"; break;
		}

		sb.DrawString(sb.pSmallFont, ProtectionString, (0, BaseYOffset + 130) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GREEN);

		// [Ace] Roomba stuff.
		sb.DrawString(sb.pSmallFont, Vacuum ? "\c[Green]We shall collect items for you.\c-" : "\c[Red]We shall not collect anything.\c-", (0, BaseYOffset + 140) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GREEN);
	}

	override int GetSbarNum(int flags)
	{
		let HDHud = HDStatusBar(StatusBar);

		int Frag =  WeaponStatus[SCProp_Frag];
		HDHud.SavedColour = Frag >= MinFrag ? Font.CR_GREEN : Font.CR_RED;
		return Frag;
	}

	override bool AddSpareWeapon(actor newowner)
	{
		let Cube = HDSoulCube(newowner.FindInventory("HDSoulCube"));
		if (Cube)
		{
			if (self != Cube)
			{
				A_StartSound("SoulCube/Use", CHAN_WEAPON, volume: 0.5);
				Cube.WeaponStatus[SCProp_Frag] += WeaponStatus[SCProp_Frag] + 10;
				Destroy();
			}
		}
		return false;
	}

	// override void InitializeWepStats(bool idfa)
	// {
	// 	WeaponStatus[SCProp_Frag] = MaxFrag;
	// }

	override void ActualPickup(actor other, bool silent)
	{
		if (!other)
		{
			return;
		}

		if (Destination)
		{
			Destination.Destroy();
		}

		for (int i = 0; i < VacuumedClasses.Size(); ++i)
		{
			Class<Inventory> cls = VacuumedClasses[i];
			if (!cls)
			{
				continue;
			}
			
			int InvAmount = CountInv(cls);
			if (InvAmount > 0)
			{
				int MaxGiveAmount = 1000 - other.CountInv(cls);
				int GiveAmount = min(InvAmount, MaxGiveAmount);
				
				other.A_GiveInventory(cls, GiveAmount);
				A_TakeInventory(cls, GiveAmount);

				if (InvAmount > GiveAmount)
				{
					// [Ace] Drop excess if player can't pick up more.
					A_DropInventory(cls, InvAmount - GiveAmount);
				}
			}
		}

		Active = false;
		bNOGRAVITY = false;
		ShootTicker = 0;

		Super.ActualPickup(other, silent);
	}

	override void DoEffect()
	{
		if (WeaponStatus[SCProp_Frag] < MaxFrag && level.time % (35 * 3) == 0 && !random(0, 1))
		{
			let Iterator = BlockThingsIterator.Create(owner, MaxRange);
			while (Iterator.Next())
			{
				if (Iterator.thing is 'BFGNecroShard')
				{
					owner.A_StartSound("SoulCube/Ammo", 9, CHANF_LOCAL, volume: 0.45);
					WeaponStatus[SCProp_Frag]++;
					Iterator.thing.Destroy();

					if (WeaponStatus[SCProp_Frag] == MinFrag)
					{
						owner.A_StartSound("SoulCube/Ready", 10, CHANF_LOCAL, volume: 0.25);
					}
					break;
				}
			}
		}

		Super.DoEffect();
	}

	override string PickupMessage()
	{
		if (!random(0, 32))
		{
			return PickupMsg.."\nEternal blues and spiritual armor will come to you if you say \"thank you cuob\".";
		}
		return PickupMsg;
	}

	private action void VacuumItems()
	{
		for (int i = 0; i < invoker.VacuumedClasses.Size(); ++i)
		{
			class<HDPickup> a = invoker.VacuumedClasses[i];
			if (!a || CountInv(a) >= 1000)
			{
				continue;
			}

			if (CheckProximity(a, MaxRange / 2, 1, CPXF_SETTRACER | CPXF_CLOSEST | CPXF_CHECKSIGHT))
			{
				let Item = HDPickup(tracer);
				if (!Item || Item.pos ~== (0, 0, 0))
				{
					continue;
				}

				Item.ActualPickup(self);
				break;
			}
		}
	}

	static const string VacuumedClasses[] =
	{
		"SevenMilBrass",
		"HDRel_RawBrass",
		"HDRel_RawPlastic",
		"HDRel_RawLead",
		"HDRel_RawPowder"
	};

	const MinFrag = 5;
	const MaxFrag = 20;
	const MaxRange = 512;
	bool Active;
	bool Vacuum;
	int ShootTicker;
	CubeDestination Destination;
	HDPlayerPawn OwningPlayer;

	Default
	{
		Speed 5;
		Height 15;
		+SLIDESONWALLS
		+INVENTORY.INVBAR
		+NODAMAGETHRUST
		+HDWEAPON.DONTFISTONDROP
		Inventory.PickupSound "misc/w_pkup";
		Inventory.PickupMessage "Picked up the soul cube.";
		Scale 0.5;
		HDWeapon.RefId "slc";
		Tag "Soul Cube";
	}

	States
	{
		Spawn:
			SLCB A 1
			{
				if (invoker.Active)
				{
					if (invoker.Vacuum)
					{
						VacuumItems();
					}

					invoker.Angle += 10;

					bool Overcharged = invoker.WeaponStatus[SCProp_Frag] > MaxFrag;

					// [Ace] Put out fire. I have no idea if this actually does anything.
					let PlayerIterator = BlockThingsIterator.Create(invoker, MaxRange);
					while (PlayerIterator.Next())
					{
						let plr = HDPlayerPawn(PlayerIterator.thing);
						if (plr && CheckSight(plr))
						{
							plr.A_GiveInventory("HDFireDouse", 5);
						}
					}

					// [Ace] Move towards owner.
					double OldAngle = invoker.Angle;
					if (invoker.Destination)
					{
						if (invoker.Distance2D(invoker.Destination) > 40 || abs(invoker.pos.z - invoker.Destination.pos.z) > 20)
						{
							vector3 diff = level.Vec3Diff(invoker.pos, invoker.Destination.pos);
							double PitchToDest = atan2(diff.z, diff.xy.length());

							A_Face(invoker.Destination, 180, 45);
							A_ChangeVelocity(0.75 * cos(PitchToDest), 0, 0.75 * sin(PitchToDest), CVF_RELATIVE);
							vel.x = clamp(vel.x, -6, 6);
							vel.y = clamp(vel.y, -6, 6);
							vel.z = clamp(vel.z, -6, 6);
						}
						else
						{
							A_ScaleVelocity(0.90);
						}
					}
					else
					{
						A_ScaleVelocity(0.90);
					}

					// [Ace] Draw range circle.
					for (double i = 0; i < 360; i += 0.75)
					{
						A_SpawnParticle(Overcharged ? 0xFF1111 : 0x44FF44, SPF_RELPOS, 1, 32, i, MaxRange, 0, -(pos.z - floorz));
					}

					// [Ace] Drop down when out of charges.
					if (invoker.WeaponStatus[SCProp_Frag] < 1)
					{
						invoker.bNOGRAVITY = false;
						invoker.Active = false;
						if (invoker.tracer)
						{
							invoker.tracer.Destroy();
						}
					}

					Array<Actor> TargetList;
					let EnemyIterator = BlockThingsIterator.Create(invoker, MaxRange);
					while (EnemyIterator.Next())
					{
						Actor ZapTarget = EnemyIterator.thing;
						if ((ZapTarget is 'BonerBall' || ZapTarget.bISMONSTER) && ZapTarget.bSHOOTABLE && !ZapTarget.bFRIENDLY && ZapTarget.Health > 0 && CheckSight(ZapTarget))
						{
							for (int i = 0; i < 2; ++i)
							{
								ZapTarget.A_SpawnParticle(Overcharged ? 0xFF1111 : 0x44FF44, 0, 25, random(2, 5), 0, frandom(-ZapTarget.Radius, ZapTarget.Radius), frandom(-ZapTarget.Radius, ZapTarget.Radius), frandom(0, ZapTarget.Height), 0, 0, random(3, 6));
							}
							TargetList.Push(ZapTarget);
							if (TargetList.Size() == 3)
							{
								break;
							}
						}
					}
					
					int Size = TargetList.Size();
					if (Size > 0 && invoker.ShootTicker++ >= (Overcharged ? 17 : 35))
					{
						invoker.ShootTicker = 0;
						invoker.WeaponStatus[SCProp_Frag]--;
						for (int i = 0; i < Size; ++i)
						{
							if (TargetList[i])
							{
								TargetList[i].DamageMobj(invoker.OwningPlayer, invoker.OwningPlayer, Overcharged ? 300 : 150, 'Holy');
								for (int j = 0; j < 80; ++j)
								{
									TargetList[i].A_SpawnParticle(Overcharged ? 0xFF1111 : 0x44FF44, SPF_RELATIVE, random(35, 70), random(4, 8), random(0, 359), frandom(0, TargetList[i].Radius), 0, frandom(0, TargetList[i].height), frandom(0, 1), 0, frandom(0, 3));
								}
							}
						}

						// [Ace] Give nearby players some blues.
						let PlayerIterator = BlockThingsIterator.Create(invoker, MaxRange);
						while (PlayerIterator.Next())
						{
							let plr = HDPlayerPawn(PlayerIterator.thing);
							if (plr && CheckSight(plr))
							{
								let Battery = HDMagAmmo(plr.FindInventory("HDBattery"));
								if (Battery)
								{
									int MinCharge = 0, LastIndex = -1; 
									for (int i = 0; i < Battery.Mags.Size(); ++i)
									{
										if (Battery.Mags[i] >= MinCharge && Battery.Mags[i] < Battery.MaxPerUnit)
										{
											MinCharge = Battery.Mags[i];
											LastIndex = i;
										}
									}
									if (LastIndex > -1)
									{
										Battery.Mags[LastIndex] = min(Battery.Mags[LastIndex] + 2 * Size, Battery.MaxPerUnit);
									}
									else
									{
										plr.regenblues += 4 * Size;
									}
								}
								else
								{
									plr.regenblues += 4 * Size;
								}
							}
						}
					}
					else if (Size == 0)
					{
						invoker.ShootTicker = 0;
					}
				}
			}
			Loop;
		Select:
			TNT1 A 0 A_AddOffset(100);
			Goto Super::Select;
		Ready:
			TNT1 A 1
			{
				if (PressingUser3())
				{
					A_MagManager("PickupManager");
					return;
				}

				int off = invoker.WeaponStatus[SCProp_UseOffset];
				if (off > 0)
				{
					invoker.WeaponStatus[SCProp_UseOffset] = off * 2 / 3;
				}

				if (JustPressed(BT_ZOOM))
				{
					invoker.Vacuum = !invoker.Vacuum;
				}
				else if (PressingFire() || PressingAltfire())
				{
					SetWeaponState("Lower");
					return;
				}

				A_WeaponReady(WRF_ALLOWUSER3 | WRF_NOFIRE);
			}
			Goto ReadyEnd;
		Lower:
			TNT1 AA 1 A_AddOffset(6);
			TNT1 AAAA 1 A_AddOffset(14);
			TNT1 AAAA 1 A_AddOffset(30);
			TNT1 A 0 A_JumpIf(!PressingFire() && !PressingAltfire(), "Ready");
			TNT1 A 1
			{
				if (invoker.WeaponStatus[SCProp_Frag] < MinFrag)
				{
					SetWeaponState("Nope");
					return;
				}

				if (PressingFire() || PressingAltfire())
				{
					if (PressingFiremode() && invoker.WeaponStatus[SCProp_Frag] >= MaxFrag)
					{
						let PlayerIterator = BlockThingsIterator.Create(self, MaxRange);
						while (PlayerIterator.Next())
						{
							let SpiritTarget = HDPlayerPawn(PlayerIterator.thing);
							if (SpiritTarget && (SpiritTarget == self || CheckSight(SpiritTarget)))
							{
								for (int i = 0; i < 360; ++i)
								{
									if (!random(0, 2))
									{
										SpiritTarget.A_SpawnParticle("44FF44", SPF_RELATIVE, random(35, 70), random(2, 4), i, random(8, 42), 0, frandom(0, SpiritTarget.height), 0, 0, frandom(0.5, 3), 0, 0, frandom(-0.05, 0));
									}
								}
								SpiritTarget.A_GiveInventory("SpiritualArmour", 1);
								invoker.WeaponStatus[SCProp_Frag] -= MaxFrag;
							}
						}
					
						A_StartSound("SoulCube/Use", CHAN_WEAPON, volume: 0.5);
						SetWeaponState("Nope");
						return;
					}

					invoker.Destination = CubeDestination(Spawn("CubeDestination", pos));
					if (PressingAltfire())
					{
						Actor a = AimTarget();
						if (a && Distance3D(a) < 512)
						{
							invoker.Destination.master = a;
							invoker.OwningPlayer = HDPlayerPawn(self);
						}
						else
						{
							SetWeaponState("Nope");
							return;
						}
					}
					else
					{
						invoker.Destination.master = self;
					}

					DropInventory(invoker);
					invoker.A_StartSound("SoulCube/Use", CHAN_WEAPON, volume: 0.5);
					invoker.Active = true;
					invoker.bNOGRAVITY = true;
				}
			}
			Wait;
	}
}

class CubeDestination : Actor
{
	Default
	{
		+NOINTERACTION
	}

	States
	{
		Spawn:
			TNT1 A 1
			{
				if (master && master.Health > 0)
				{
					Warp(master, master.radius + 10, -(master.radius + 10), master.height + 4, flags: WARPF_NOCHECKPOSITION);
				}
				else
				{
					Destroy();
				}
			}
			Loop;
	}
}
