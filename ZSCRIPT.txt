version "4.0"

class SoulCubeHandler : StaticEventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'Lumberjack':
				if (random[cuberand]() <= 64)
				{
					e.Replacement = "HDSoulCube";
				}
				break;
		}
	}
}

class HDSoulCube : HDWeapon
{
	enum SCProperty
	{
		SCProp_UseOffset,
		SCProp_Frag,
		SCProp_CubeLevel
	}

	action void A_AddOffset(int ofs)
	{
		invoker.WeaponStatus[SCProp_UseOffset] += ofs;
	}

	override string, double GetPickupSprite() { return "SLCBA3A7", 0.5; }
	override string GetHelpText()
	{
		string BaseString = WEPHELP_FIRE.."  Attack";
		if (WeaponStatus[SCProp_CubeLevel] > 0)
		{
			BaseString = BaseString.."\n"..WEPHELP_FIRE.."+"..WEPHELP_FIREMODE.."  Grant spiritual armor";
		}
		return BaseString;
	}
	override double WeaponBulk() { return 80 * Amount; }

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		vector2 bob = hpl.hudbob * 0.3;
		int Offset = WeaponStatus[SCProp_UseOffset];
		bob.y += Offset;
		int BaseYOffset = -170;
		
		sb.DrawImage("SLCBA3A7", (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER, alpha: 1.0, scale:(2, 2));
		BaseYOffset += 50;
		if (WeaponStatus[SCProp_Frag] >= MinFrag)
		{
			sb.DrawString(sb.pSmallFont, "Use us", (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GREEN);
		}
		else
		{
			sb.DrawString(sb.pSmallFont, "Not enough frag", (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GOLD);
		}
		BaseYOffset += 10;

		// [Ace] Aggro.
		string AggroString = "\c[SC_AggroNone]Your soul is unharmed\c-";
		if (hpl.aggravateddamage > 0)
		{
			if (hpl.aggravateddamage <= 20)
			{
				AggroString = "\c[SC_AggroVLow]Your soul is strong\c-";
			}
			else if (hpl.aggravateddamage <= 40)
			{
				AggroString = "\c[SC_AggroLow]Your soul needs healing\c-";
			}
			else if (hpl.aggravateddamage <= 60)
			{
				AggroString = "\c[SC_AggroMed]Your soul has been burnt\c-";
			}
			else if (hpl.aggravateddamage <= 80)
			{
				AggroString = "\c[SC_AggroHigh]Your soul is nearly torn apart\c-";
			}
			else
			{
				AggroString = "\c[SC_AggroUlt]Your soul has been utterly scorched\c-";
			}
		}
		sb.DrawString(sb.pSmallFont, AggroString, (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER);
		BaseYOffset += 10;

		// [Ace] Blues.
		string BluesString = "\c[White]We detect nothing supernatural in you\c-";
		if (hpl.regenblues > 0)
		{
			if (hpl.regenblues <= 72)
			{
				BluesString = "\c[SC_BluesVLow]There is barely anything supernatural in you\c-";
			}
			else if (hpl.regenblues <= 144)
			{
				BluesString = "\c[SC_BluesLow]There is something supernatural in you\c-";
			}
			else if (hpl.regenblues <= 777)
			{
				BluesString = "\c[SC_BluesMed]You emanate a strange supernatural aura\c-";
			}
			else if (hpl.regenblues <= 1554)
			{
				BluesString = "\c[SC_BluesHigh]Your body is infused with the supernatural\c-";
			}
			else
			{
				BluesString = "\c[SC_BluesUlt]Holy burning hand of wrath\c-";
			}
		}
		sb.DrawString(sb.pSmallFont, BluesString, (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER);
		BaseYOffset += 10;

		// [Ace] Spiritual armor.
		string ProtectionString = "\c[Red]You are not protected\c-";
		switch (sb.GetAmount("SpiritualArmour"))
		{
			case 1: ProtectionString = "\c[Orange]You are barely protected\c-"; break;
			case 2: ProtectionString = "\c[Yellow]The spirits guard your soul\c-"; break;
			case 3: ProtectionString = "\c[Green]Your soul has transcended beyond harm\c-"; break;
		}
		sb.DrawString(sb.pSmallFont, ProtectionString, (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER);
		BaseYOffset += 10;
	}

	override int GetSbarNum(int flags)
	{
		let HDHud = HDStatusBar(StatusBar);

		int Frag =  WeaponStatus[SCProp_Frag];
		HDHud.SavedColour = Frag >= MinFrag ? Font.CR_GREEN : Font.CR_RED;
		return Frag;
	}

	override bool AddSpareWeapon(actor newowner)
	{
		// [Ace] This pointer is for the existing cube in the player's inventory.
		let Cube = HDSoulCube(newowner.FindInventory("HDSoulCube"));
		if (Cube)
		{
			if (self != Cube)
			{
				A_StartSound("SoulCube/Use", CHAN_WEAPON, volume: 0.5);
				if (Cube.WeaponStatus[SCProp_CubeLevel] < MaxLevel)
				{
					Cube.WeaponStatus[SCProp_CubeLevel] = min(Cube.WeaponStatus[SCProp_CubeLevel] + WeaponStatus[SCProp_CubeLevel] + 1, MaxLevel);
				}
				else
				{
					Cube.WeaponStatus[SCProp_Frag] += WeaponStatus[SCProp_Frag] + 10;
				}
				Destroy();
			}
		}
		return false;
	}

	// override void InitializeWepStats(bool idfa)
	// {
	// 	WeaponStatus[SCProp_Frag] = 100; // [Ace] Debug stuff.
	// }

	override bool OnGrab(Actor other)
	{
		if (Active && PickupTimer <= 0)
		{
			PickupTimer = 10;
			return false;
		}

		return Super.OnGrab(other);
	}

	override void ActualPickup(actor other, bool silent)
	{
		if (!other)
		{
			return;
		}

		if (Destination)
		{
			Destination.Destroy();
		}

		Active = false;
		bNOGRAVITY = false;

		Super.ActualPickup(other, silent);
	}

	override void DoEffect()
	{
		if (WeaponStatus[SCProp_Frag] < GetMaxFrag() && level.time % (105 - 15 * WeaponStatus[SCProp_CubeLevel]) == 0 && !random(0, 1))
		{
			let Iterator = BlockThingsIterator.Create(owner, MaxRange);
			while (Iterator.Next())
			{
				if (Iterator.thing is 'BFGNecroShard')
				{
					owner.A_StartSound("SoulCube/Ammo", 9, CHANF_LOCAL, volume: 0.45);
					WeaponStatus[SCProp_Frag]++;
					Iterator.thing.Destroy();

					if (WeaponStatus[SCProp_Frag] == MinFrag)
					{
						owner.A_StartSound("SoulCube/Ready", 10, CHANF_LOCAL, volume: 0.25);
					}
					break;
				}
			}
		}

		let plr = HDPlayerPawn(owner);
		if (!Active && WeaponStatus[SCProp_Frag] >= MinFrag && plr && plr.incaptimer > 50 && plr.incapacitated > 0)
		{
			A_DeployCube(false);
		}

		Super.DoEffect();
	}

	override string PickupMessage()
	{
		if (!random(0, 32))
		{
			return PickupMsg.."\nEternal blues and spiritual armor will come to you if you say \"thank you cuob\".";
		}
		return PickupMsg;
	}

	private action void A_DeployCube(bool anchor)
	{
		let plr = invoker.owner;
		invoker.Destination = CubeDestination(Spawn("CubeDestination", pos));
		if (anchor)
		{
			Actor a = AimTarget();
			if (a && Distance3D(a) <= MaxRange)
			{
				invoker.Destination.master = a;
				invoker.master = plr;
			}
			else
			{
				SetWeaponState("Nope");
				return;
			}
		}
		else
		{
			invoker.Destination.master = invoker.owner;
		}

		plr.DropInventory(invoker);
		invoker.A_StartSound("SoulCube/Use", CHAN_WEAPON, volume: 0.5);
		invoker.Active = true;
		invoker.bNOGRAVITY = true;
	}

	private clearscope int GetMaxFrag()
	{
		return 20 + 5 * WeaponStatus[SCProp_CubeLevel];
	}

	const MinFrag = 5;
	const MaxRange = 512;
	const MaxLevel = 4;
	bool Active;
	int PickupTimer;
	int ShootTicker;
	CubeDestination Destination;

	Default
	{
		Speed 5;
		Height 15;
		+SLIDESONWALLS
		+INVENTORY.INVBAR
		+NODAMAGETHRUST
		+HDWEAPON.DONTFISTONDROP
		Inventory.PickupSound "misc/w_pkup";
		Inventory.PickupMessage "Picked up the soul cube.";
		Scale 0.5;
		HDWeapon.RefId "slc";
		Tag "Soul Cube";
	}

	States
	{
		Spawn:
			SLCB A 1
			{
				invoker.PickupTimer--;
				if (invoker.Active)
				{
					invoker.Angle += 10;
					int CubeLevel = invoker.WeaponStatus[SCProp_CubeLevel];

					// [Ace] Move towards owner.
					double OldAngle = invoker.Angle;
					if (invoker.Destination)
					{
						if (invoker.Distance2D(invoker.Destination) > 40 || abs(invoker.pos.z - invoker.Destination.pos.z) > 20)
						{
							vector3 diff = level.Vec3Diff(invoker.pos, invoker.Destination.pos);
							double PitchToDest = atan2(diff.z, diff.xy.length());

							A_Face(invoker.Destination, 180, 45);
							A_ChangeVelocity(1.0 * cos(PitchToDest), 0, 1.0 * sin(PitchToDest), CVF_RELATIVE);
							vel.x = clamp(vel.x, -6, 6);
							vel.y = clamp(vel.y, -6, 6);
							vel.z = clamp(vel.z, -6, 6);
						}
						else
						{
							A_ScaleVelocity(0.9);
						}
					}
					else
					{
						A_ScaleVelocity(0.9);
					}

					Color PartCol;
					switch (CubeLevel)
					{
						case 0: PartCol = 0x44FF44; break;
						case 1: PartCol = 0x99FF11; break;
						case 2: PartCol = 0xFFFF11; break;
						case 3: PartCol = 0xFF9911; break;
						case 4: PartCol = 0xFF1111; break;
					}

					// [Ace] Draw range circle.
					for (double i = 0; i < 360; i += 0.75)
					{
						A_SpawnParticle(PartCol, SPF_RELPOS | SPF_FULLBRIGHT, 1, 40, i, MaxRange, 0, -(pos.z - floorz), startalphaf: 0.25);
					}

					// [Ace] Drop down when out of charges.
					if (invoker.WeaponStatus[SCProp_Frag] < 1)
					{
						invoker.bNOGRAVITY = false;
						invoker.Active = false;
						if (invoker.tracer)
						{
							invoker.tracer.Destroy();
						}
					}

					// [Ace] Target locator.
					Array<Actor> TargetList;
					Array<HDPlayerPawn> PlayerList;
					int Size = 0;
					let Iterator = BlockThingsIterator.Create(invoker, MaxRange);
					while (Iterator.Next())
					{
						if (Distance3D(Iterator.thing) > MaxRange)
						{
							continue;
						}

						if (Size < 3)
						{
							Actor ZapTarget = Iterator.thing;
							if ((ZapTarget is 'BonerBall' || ZapTarget.bISMONSTER) && ZapTarget.bSHOOTABLE && !ZapTarget.bFRIENDLY && ZapTarget.Health > 0 && CheckSight(ZapTarget))
							{
								for (int i = 0; i < 2; ++i)
								{
									ZapTarget.A_SpawnParticle(PartCol, 0, 25, random(2, 5), 0, frandom(-ZapTarget.Radius, ZapTarget.Radius), frandom(-ZapTarget.Radius, ZapTarget.Radius), frandom(0, ZapTarget.Height), 0, 0, random(3, 6));
								}

								TargetList.Push(ZapTarget);
								Size = TargetList.Size();
								continue;
							}
						}

						if (Iterator.thing is 'HDPlayerPawn' && CheckSight(Iterator.thing))
						{
							PlayerList.Push(HDPlayerPawn(Iterator.thing));
						}
					}

					// [Ace] Fire, incap, and regeneration.
					for (int i = 0; i < PlayerList.Size(); ++i)
					{
						let plr = PlayerList[i];
						
						plr.A_GiveInventory("HDFireDouse", 20);
						if (CubeLevel >= 1 && plr.incaptimer > 0)
						{
							plr.incaptimer = max(plr.incaptimer - CubeLevel, 0);
						}
						if (CubeLevel >= 1 && plr.Health < plr.MaxHealth() && level.time % int(floor(175 - 11.66 * (CubeLevel - 1))) == 0)
						{
							plr.A_GiveInventory("Health", 1);
						}
					}

					// [Ace] Attack stuff.
					if (Size > 0)
					{
						if (++invoker.ShootTicker >= 35 - 5 * CubeLevel)
						{
							invoker.ShootTicker = 0;
							invoker.WeaponStatus[SCProp_Frag]--;
							for (int i = 0; i < Size; ++i)
							{
								if (TargetList[i])
								{
									TargetList[i].DamageMobj(invoker.master, invoker.master, 150 + 25 * CubeLevel, 'Holy');
									for (int j = 0; j < 80; ++j)
									{
										TargetList[i].A_SpawnParticle(PartCol, SPF_RELATIVE, random(35, 70), random(4, 8), random(0, 359), frandom(0, TargetList[i].Radius), 0, frandom(0, TargetList[i].height), frandom(0, 1), 0, frandom(0, 3));
									}
								}
							}

							for (int i = 0; i < PlayerList.Size(); ++i)
							{
								let plr = PlayerList[i];

								let Battery = HDMagAmmo(plr.FindInventory("HDBattery"));
								if (Battery)
								{
									// [Ace] Find the highest battery that's not full.
									int MinCharge = 0, LastIndex = -1; 
									for (int i = 0; i < Battery.Mags.Size(); ++i)
									{
										if (Battery.Mags[i] >= MinCharge && Battery.Mags[i] < Battery.MaxPerUnit)
										{
											MinCharge = Battery.Mags[i];
											LastIndex = i;
										}
									}

									if (LastIndex > -1)
									{
										Battery.Mags[LastIndex] = min(Battery.Mags[LastIndex] + Size, Battery.MaxPerUnit);
									}
									else
									{
										plr.regenblues += 4 * Size;
									}
								}
								else
								{
									plr.regenblues += 4 * Size;
								}
							}
						}
					}
					else
					{
						invoker.ShootTicker = 0;
					}
				}
			}
			Loop;
		Select:
			TNT1 A 0 A_AddOffset(100);
			Goto Super::Select;
		Ready:
			TNT1 A 1
			{
				if (PressingUser3())
				{
					A_MagManager("PickupManager");
					return;
				}

				int off = invoker.WeaponStatus[SCProp_UseOffset];
				if (off > 0)
				{
					invoker.WeaponStatus[SCProp_UseOffset] = off * 2 / 3;
				}

				if (PressingFire() || PressingAltfire())
				{
					SetWeaponState("Lower");
					return;
				}

				A_WeaponReady(WRF_ALLOWUSER3 | WRF_NOFIRE);
			}
			Goto ReadyEnd;
		Lower:
			TNT1 AA 1 A_AddOffset(6);
			TNT1 AAAA 1 A_AddOffset(18);
			TNT1 AAAAA 1 A_AddOffset(36);
			TNT1 A 0 A_JumpIf(!PressingFire() && !PressingAltfire(), "Ready");
			TNT1 A 1
			{
				if (invoker.WeaponStatus[SCProp_Frag] < MinFrag)
				{
					SetWeaponState("Nope");
					return;
				}

				if (PressingFire() || PressingAltfire())
				{
					if (PressingFiremode() && CountInv("SpiritualArmour") < min(3, invoker.WeaponStatus[SCProp_CubeLevel]) && invoker.WeaponStatus[SCProp_Frag] >= 20)
					{
						let PlayerIterator = BlockThingsIterator.Create(self, MaxRange);
						while (PlayerIterator.Next())
						{
							let SpiritTarget = HDPlayerPawn(PlayerIterator.thing);
							if (SpiritTarget && (SpiritTarget == self || CheckSight(SpiritTarget)))
							{
								for (int i = 0; i < 360; ++i)
								{
									if (!random(0, 2))
									{
										SpiritTarget.A_SpawnParticle("44FF44", SPF_RELATIVE, random(35, 70), random(2, 4), i, random(8, 42), 0, frandom(0, SpiritTarget.height), 0, 0, frandom(0.5, 3), 0, 0, frandom(-0.05, 0));
									}
								}
								SpiritTarget.A_GiveInventory("SpiritualArmour", 1);
								invoker.WeaponStatus[SCProp_Frag] -= 20;
							}
						}
					
						A_StartSound("SoulCube/Use", CHAN_WEAPON, volume: 0.5);
						SetWeaponState("Nope");
						return;
					}
					A_DeployCube(PressingAltfire());
				}
			}
			Wait;
	}
}

class CubeDestination : Actor
{
	Default
	{
		+NOINTERACTION
	}

	States
	{
		Spawn:
			TNT1 A 1
			{
				if (master && master.Health > 0)
				{
					Warp(master, master.radius + 10, -(master.radius + 10), master.height + 4, flags: WARPF_NOCHECKPOSITION);
				}
				else
				{
					Destroy();
				}
			}
			Loop;
	}
}
