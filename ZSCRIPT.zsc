version "4.0"

class SoulCubeHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'Lumberjack':
				if (random[cuberand]() <= 64)
				{
					e.Replacement = "HDSoulCube";
				}
				break;
		}
	}

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "SC_ReturnToOwner")
		{
			let plr = players[e.Player].mo;
			ThinkerIterator it = ThinkerIterator.Create("HDSoulCube", Thinker.STAT_DEFAULT);
			HDSoulCube SC;
			while ((SC = HDSoulCube(it.Next())))
			{
				if (SC.master == plr && SC.Destination && SC.CheckSight(SC.master))
				{
					SC.Destination.master = plr;
					return;
				}
			}
		}
	}
}

class HDSoulCube : HDWeapon
{
	enum SCFlags
	{
		SCF_AlreadyPickedUp = 1
	}

	enum SCProperty
	{
		SCProp_Flags,
		SCProp_UseOffset,
		SCProp_Frag,
		SCProp_CubeLevel,
		SCProp_CubeExperience,
		SCProp_TimeWithOwner,
		SCProp_LastOwnerNumber
	}

	action void A_AddOffset(int ofs)
	{
		invoker.WeaponStatus[SCProp_UseOffset] += ofs;
	}
	
	override string, double GetPickupSprite() { return "SLCBA3A7", 0.5; }
	override string GetHelpText()
	{
		string BaseString = WEPHELP_FIRE.."  Attack\n"
		..WEPHELP_ALTFIRE.."  Anchor to something";
		if (A_GetCubeLevel() > 0)
		{
			BaseString = BaseString.."\n"..WEPHELP_FIRE.."+"..WEPHELP_FIREMODE.."  Grant spiritual armor";
		}
		return BaseString;
	}
	override double WeaponBulk() { return 80 * Amount; }

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		vector2 bob = hpl.hudbob * 0.3;
		int Offset = WeaponStatus[SCProp_UseOffset];
		bob.y += Offset;
		int BaseYOffset = -170;
		
		sb.DrawImage("SLCBA3A7", (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER | sb.DI_TRANSLATABLE, alpha: 1.0, scale:(2, 2));
		BaseYOffset += 50;
		if (WeaponStatus[SCProp_Frag] >= MinFrag)
		{
			sb.DrawString(sb.pSmallFont, "Use us", (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GREEN);
		}
		else
		{
			sb.DrawString(sb.pSmallFont, "Not enough frag", (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GOLD);
		}
		BaseYOffset += 10;

		// [Ace] Aggro.
		string AggroString = "\c[SC_AggroNone]Your soul is unharmed\c-";
		if (hpl.aggravateddamage > 0)
		{
			if (hpl.aggravateddamage <= 20)
			{
				AggroString = "\c[SC_AggroVLow]Your soul is weakening\c-";
			}
			else if (hpl.aggravateddamage <= 40)
			{
				AggroString = "\c[SC_AggroLow]Your soul needs healing\c-";
			}
			else if (hpl.aggravateddamage <= 60)
			{
				AggroString = "\c[SC_AggroMed]Your soul has been burnt\c-";
			}
			else if (hpl.aggravateddamage <= 80)
			{
				AggroString = "\c[SC_AggroHigh]Your soul is nearly torn apart\c-";
			}
			else if (hpl.aggravateddamage <= 100)
			{
				AggroString = "\c[SC_AggroExtr]Your soul has been utterly scorched\c-";
			}
			else
			{
				AggroString = "\c[SC_AggroUlt]You are already dead\c-";
			}
		}
		sb.DrawString(sb.pSmallFont, AggroString, (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER);
		BaseYOffset += 10;

		// [Ace] Blues.
		string BluesString = "\c[White]We detect nothing supernatural in you\c-";
		if (hpl.regenblues > 0)
		{
			if (hpl.regenblues < HDBLU_BOTTLE * HDBLU_MOUTH)
			{
				BluesString = "\c[SC_BluesVLow]A faint supernatural presence can be felt\c-";
			}
			else if (hpl.regenblues < HDBLU_BALL)
			{
				BluesString = "\c[SC_BluesLow]There is something supernatural in you\c-";
			}
			else if (hpl.regenblues < HDBLU_BALL * 2)
			{
				BluesString = "\c[SC_BluesMed]You emanate a strange supernatural aura\c-";
			}
			else if (hpl.regenblues < HDBLU_BALL * 4)
			{
				BluesString = "\c[SC_BluesHigh]Your body is infused with the supernatural\c-";
			}
			else if (hpl.regenblues < HDBLU_BALL * 12)
			{
				BluesString = "\c[SC_BluesUlt]Holy burning hand of wrath\c-";
			}
			else
			{
				BluesString = "\c[SC_BluesGod]Disciple of God\c-";
			}
		}
		sb.DrawString(sb.pSmallFont, BluesString, (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER);
		BaseYOffset += 10;

		// [Ace] Spiritual armor.
		string ProtectionString = "\c[Red]You are not protected\c-";
		switch (sb.GetAmount("SpiritualArmour"))
		{
			case 1: ProtectionString = "\c[Orange]You are protected by a thin veil\c-"; break;
			case 2: ProtectionString = "\c[Yellow]The spirits guard your soul\c-"; break;
			case 3: ProtectionString = "\c[Green]Your soul has transcended beyond harm\c-"; break;
		}
		sb.DrawString(sb.pSmallFont, ProtectionString, (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER);
		BaseYOffset += 10;
	}

	override int GetSbarNum(int flags)
	{
		let HDHud = HDStatusBar(StatusBar);

		int Frag =  WeaponStatus[SCProp_Frag];
		HDHud.SavedColour = Frag >= MinFrag ? Font.CR_GREEN : Font.CR_RED;
		return Frag;
	}

	override int DisplayAmount()
	{
		let HDHud = HDStatusBar(StatusBar);
		int col = Font.FindFontColor("SC_Level_1");
		int lvl = A_GetCubeLevel();
		switch (lvl)
		{
			case 1: col = Font.FindFontColor("SC_Level_2"); break;
			case 2: col = Font.CR_YELLOW; break;
			case 3: col = Font.CR_ORANGE; break;
			case 4: col = Font.CR_RED; break;
			case 5: col = Font.CR_PURPLE; break;
		}
		HDHud.SavedColour = col;
		return lvl;
	}

	action clearscope int A_GetCubeLevel()
	{
		int lvl = invoker.WeaponStatus[SCProp_CubeLevel];
		if (invoker.PetTicker > 0)
		{
			lvl++;
		}
		return lvl;
	}

	action clearscope int A_GetParticleColor(int lvl)
	{
		switch (lvl)
		{
			case 0: return 0x44FF44;
			case 1: return 0x99FF11;
			case 2: return 0xFFFF11;
			case 3: return 0xFF9911;
			case 4: return 0xFF1111;
			case 5: return 0xA100E6;
		}
		return 0;
	}

	override void LoadoutConfigure(string input)
	{
		int StartLevel = GetLoadoutVar(input, "level", 1);
		if (StartLevel > 0)
		{
			WeaponStatus[SCProp_CubeLevel] = min(StartLevel, ExperienceReqs.Size());
		}

		int StartFrag = GetLoadoutVar(input, "frag", 3);
		if (StartFrag > 0)
		{
			WeaponStatus[SCProp_Frag] = StartFrag;
		}
	}

	override void InitializeWepStats(bool idfa)
	{
		PetTicker = PetCooldown;
	}

	override bool OnGrab(Actor other)
	{
		if (Active && PickupTimer <= 0)
		{
			PickupTimer = 10;
			return false;
		}

		if (Destination)
		{
			Destination.Destroy();
		}

		Active = false;
		bNOGRAVITY = false;

		if (hdsc_archermode)
		{
			if (!random(0, 5) && !(WeaponStatus[SCProp_Flags] & SCF_AlreadyPickedUp))
			{
				A_PlayArcherSound(other, "PickupSpecial");
			}
			else
			{
				A_PlayArcherSound(other, !random(0, 28) ? "PickupRare" : "PickupNormal");
			}
			WeaponStatus[SCProp_Flags] |= SCF_AlreadyPickedUp;
		}

		HasAnnounced[2] = false;

		return Super.OnGrab(other);
	}

	override void ActualPickup(Actor other, bool silent)
	{
		// [Ace] This pointer is for the existing cube in the player's inventory.
		let Cube = HDSoulCube(other.FindInventory("HDSoulCube"));
		if (Cube)
		{
			A_StartSound("SC/Activate", CHAN_WEAPON, volume: 0.3);
			if (hdsc_archermode)
			{
				A_PlayArcherSound(other, "ConsumeNormal");
			}
			Cube.A_GainExperience(200);
			Cube.WeaponStatus[SCProp_Frag] += WeaponStatus[SCProp_Frag] + 15;
			Destroy();
			return;
		}
		
		Super.ActualPickup(other, silent);
	}

	override void Tick()
	{
		Super.Tick();

		if (GetAge() % 35 == 0 && PetCount > 0)
		{
			PetCount--;
		}

		PetTicker--;
		if (PetTicker > 0 && !random(0, 2))
		{
			A_ChangeVelocity(frandom(-0.05, 0.05), frandom(-0.05, 0.05), frandom(0.1, 0.25), CVF_RELATIVE);
		}
		else if (PetTicker <= PetCooldown)
		{
			for (int i = 0; i < MAXPLAYERS; ++i)
			{
				let plr = HDPlayerPawn(players[i].mo);
				if (!plr)
				{
					continue;
				}

				if (plr.player)
				{
					let wpn = HDWeaponGrabber(plr.player.ReadyWeapon);
					if (!wpn)
					{
						continue;
					}
					if (wpn.grabbed == self && !HasBeenPet)
					{
						HasBeenPet = true;
						A_ChangeVelocity(frandom(-0.15, 0.15), frandom(-0.15, 0.15), frandom(0.2, 0.6), CVF_RELATIVE);
						if (++PetCount == 6)
						{
							// [Ace] Because even instruments of total annihilation need emotional support.
							if (hdsc_archermode)
							{
								A_PlayArcherSound(self, !random(0, 5) ? (WeaponStatus[SCProp_TimeWithOwner] > 35 * 60 * 120 && !random(0, 3) ? "PetUltraRare" : "PetRare") : "PetNormal");
							}
							PetTicker = 35 * 120;
							PetCount = 0;
							A_StartSound("SC/Activate", CHAN_WEAPON, volume: 0.3);
							for (int i = 0; i < 64; ++i)
							{
								A_SpawnParticle(A_GetParticleColor(A_GetCubeLevel()), SPF_RELATIVE, random(35, 70), random(2, 4), random(0, 359), frandom(0, radius), 0, frandom(0, height), 0, 0, frandom(0.5, 3), 0, 0, frandom(-0.05, 0));
							}
						}
					}
					else if (wpn.grabbed != self)
					{
						HasBeenPet = false;
					}
					break;
				}
			}
		}

		if (!master)
		{
			return;
		}

		if (JokerTicker > 0)
		{
			JokerTicker--;
		}
		else if (master.vel.z < -5 && HDPlayerPawn(master).incapacitated > 0 && HDPlayerPawn(master).incaptimer > 105)
		{
			JokerTicker = 35 * 60 * 20;
			if (hdsc_archermode)
			{
				A_PlayArcherSound(self, "JokerStairs");
			}
		}
	}

	override void DoEffect()
	{
		if (WeaponStatus[SCProp_LastOwnerNumber] != owner.PlayerNumber())
		{
			WeaponStatus[SCProp_LastOwnerNumber] = owner.PlayerNumber();
			WeaponStatus[SCProp_TimeWithOwner] = 0;
		}
		else
		{
			WeaponStatus[SCProp_TimeWithOwner]++;
		}

		int MaxFrag = GetMaxFrag();
		if (WeaponStatus[SCProp_Frag] < MaxFrag && level.time % int(105 - 17.5 * A_GetCubeLevel()) == 0 && !random(0, 1))
		{
			// [Ace] This is actually a square but it's invisible so who cares?
			let Iterator = BlockThingsIterator.Create(owner, MaxRange);
			while (Iterator.Next())
			{
				bool IsSuperShard = Iterator.thing is 'NecroGhostShard';
				bool IsRegularShard = Iterator.thing is 'BFGNecroShard';

				if (IsRegularShard || IsSuperShard && !random(0, 2))
				{
					owner.A_StartSound("SC/Ammo", 9, CHANF_LOCAL, volume: 0.45);
					WeaponStatus[SCProp_Frag] += IsSuperShard ? 3 : 1;
					A_GainExperience(IsSuperShard ? 3 : 1);
					Iterator.thing.Destroy();

					if (!HasAnnounced[0] && WeaponStatus[SCProp_Frag] >= MinFrag)
					{
						if (hdsc_archermode)
						{
							A_PlayArcherSound(owner, "Ready", CHANF_LOCAL);
						}
						else
						{
							owner.A_StartSound("SC/Original/Ready", 10, CHANF_LOCAL, volume: 0.40);
						}
						HasAnnounced[0] = true;
					}

					if (!HasAnnounced[1] && WeaponStatus[SCProp_Frag] >= MaxFrag && hdsc_archermode)
					{
						if (!random(0, 1))
						{
							A_PlayArcherSound(owner, !random(0, 12) ? "FullRare" : "FullNormal", CHANF_LOCAL);
						}
						HasAnnounced[1] = true;
					}

					break;
				}
			}
		}
		else if (hdsc_archermode && WeaponStatus[SCProp_Frag] >= MaxFrag && ++MaxFragTicker >= (35 * 60 * 15))
		{
			A_PlayArcherSound(owner, "MaxedOut", CHANF_LOCAL);
			MaxFragTicker = 0;
		}

		let plr = HDPlayerPawn(owner);
		if (!Active && WeaponStatus[SCProp_Frag] >= MinFrag && plr && plr.incapacitated > 0)
		{
			A_DeployCube(false, true);
		}

		Super.DoEffect();
	}

	override string PickupMessage()
	{
		string BaseMessage = "Picked up the soul cube.";
		if (hdsc_archermode)
		{
			BaseMessage = BaseMessage.." You hear strange voices coming out of it. It is... speaking to you?";
		}
		if (!random(0, 32))
		{
			BaseMessage.."\nEternal blues and spiritual armor will come to you if you say \"thank you cuob\".";
		}
		return BaseMessage;
	}

	private action void A_DeployCube(bool anchor, bool fromIncap)
	{
		let plr = invoker.owner;
		invoker.Destination = CubeDestination(Spawn("CubeDestination", pos));
		if (anchor)
		{
			FLineTraceData TraceData;
			LineTrace(angle, MaxRange, pitch, TRF_THRUBLOCK | TRF_THRUHITSCAN | TRF_NOSKY | TRF_SOLIDACTORS, height / 2 + 4, 0, 0, TraceData);
			
			if (TraceData.HitActor)
			{
				invoker.Destination.master = TraceData.HitActor;
			}
			else
			{
				invoker.Destination.SetOrigin(TraceData.HitLocation + (0, 0, 16), false);
			}
		}
		else
		{
			invoker.Destination.master = invoker.owner;
		}

		invoker.master = plr;
		plr.DropInventory(invoker);
		invoker.A_StartSound("SC/Activate", CHAN_WEAPON, volume: 0.3);
		if (!fromIncap && hdsc_archermode)
		{
			A_PlayArcherSound(invoker, !random(0, 20) ? "UseRare" : "UseNormal");
		}
		invoker.Active = true;
		invoker.bNOGRAVITY = true;
	}

	private action void A_GainExperience(int amount)
	{
		let plr = invoker.owner ? invoker.owner : invoker.master;
		int cubeLevel = invoker.WeaponStatus[SCProp_CubeLevel];
		if (cubeLevel >= invoker.ExperienceReqs.Size())
		{
			return;
		}

		invoker.WeaponStatus[SCProp_CubeExperience] += amount;
		if (invoker.WeaponStatus[SCProp_CubeExperience] >= invoker.ExperienceReqs[cubeLevel])
		{
			invoker.WeaponStatus[SCProp_CubeExperience] -= invoker.ExperienceReqs[cubeLevel];
			invoker.WeaponStatus[SCProp_CubeLevel]++;
			A_StartSound("SC/Activate", CHAN_WEAPON, volume: 0.3);
			if (hdsc_archermode)
			{
				A_PlayArcherSound(plr, "LevelUp", CHANF_LOCAL);
			}
			plr.A_Log("The cube's power grows.", true);
		}
	}

	private clearscope int GetMaxFrag()
	{
		int Extra = AceCore.CheckForItem(owner, "HDArcanumTome") ? 10 : 5;
		return 20 + Extra * A_GetCubeLevel();
	}

	static void A_PlayArcherSound(Actor a, string snd, int flags = 0, double vol = 1.0, double atten = 0.5)
	{
		a.A_StopSound(10);
		a.A_StartSound("SC/Archer/"..snd, 10, flags, volume: vol, attenuation: atten);
	}

	static const int ExperienceReqs[] = { 200, 800, 1500, 2500 };
	const MinFrag = 5;
	const MaxRange = 512;
	const PetCooldown = -(35 * 60 * 20);
	private bool Active;
	private bool HasAnnounced[3];
	private int PickupTimer;
	private int ShootTicker;
	private int MaxFragTicker;
	CubeDestination Destination;
	private int PetCount;
	private bool HasBeenPet;
	private int PetTicker;
	private int JokerTicker;

	Default
	{
		Speed 5;
		Height 15;
		+SLIDESONWALLS
		+INVENTORY.INVBAR
		+HDWEAPON.DONTFISTONDROP
		+HDWEAPON.DROPTRANSLATION
		Inventory.PickupSound "misc/w_pkup";
		Scale 0.5;
		HDWeapon.RefId "slc";
		Tag "Soul Cube";
	}

	States
	{
		Spawn:
			SLCB A 1
			{
				invoker.PickupTimer--;
				if (invoker.Active)
				{
					invoker.Angle += 10;
					int cubeLevel = A_GetCubeLevel();

					// [Ace] Move towards owner.
					double oldAngle = invoker.Angle;
					if (invoker.Destination)
					{
						if (invoker.Distance2D(invoker.Destination) > 40 || abs(invoker.pos.z - invoker.Destination.pos.z) > 20)
						{
							vector3 diff = level.Vec3Diff(invoker.pos, invoker.Destination.pos);
							double PitchToDest = atan2(diff.z, diff.xy.length());

							A_Face(invoker.Destination, 180, 45);
							A_ChangeVelocity(1.0 * cos(PitchToDest), 0, 1.0 * sin(PitchToDest), CVF_RELATIVE);
							vel.x = clamp(vel.x, -6, 6);
							vel.y = clamp(vel.y, -6, 6);
							vel.z = clamp(vel.z, -6, 6);
						}
						else
						{
							A_ScaleVelocity(0.9);
						}
					}
					else
					{
						A_ScaleVelocity(0.9);
					}

					Color partCol = A_GetParticleColor(cubeLevel);

					// [Ace] Draw range circle.
					for (double i = 0; i < 360; i += 0.75)
					{
						A_SpawnParticle(partCol, SPF_RELPOS | SPF_FULLBRIGHT, 1, 40, i, MaxRange, 0, -(pos.z - floorz), startalphaf: 0.25);
					}

					// [Ace] Drop down when out of charges.
					if (invoker.WeaponStatus[SCProp_Frag] < 1)
					{
						invoker.bNOGRAVITY = false;
						invoker.Active = false;
						if (invoker.tracer)
						{
							invoker.tracer.Destroy();
						}

						if (hdsc_archermode)
						{
							A_PlayArcherSound(invoker, !random(0, 6) ? "PowerDownRare" : "PowerDownNormal");
						}
					}

					// [Ace] Target locator.
					Array<Actor> TargetList;
					Array<HDMobBase> FollowerList;
					Array<HDPlayerPawn> PlayerList;
					int HitThingCount = 0;
					let Iterator = BlockThingsIterator.Create(invoker, MaxRange);
					while (Iterator.Next())
					{
						Actor a = Iterator.thing;
						if (Distance3D(a) > MaxRange || a.Health <= 0 || !CheckSight(a, SF_SEEPASTSHOOTABLELINES | SF_IGNOREVISIBILITY))
						{
							continue;
						}

						let Necro = Necromancer(a);
						if (Necro && Necro.tics > 105 && Necro.InStateSequence(Necro.CurState, Necro.FindState('painedandgone')))
						{
							if (hdsc_archermode)
							{
								if (!invoker.HasAnnounced[2])
								{
									invoker.HasAnnounced[2] = true;
									A_PlayArcherSound(invoker, !random(0, 16) ? "ArchHuntRare" : "ArchHuntNormal");
								}
							}
							Necro.tics -= 10;
						}

						if (HitThingCount < 3 && (a is 'BonerBall' || a.bISMONSTER) && a.bSHOOTABLE && !a.bFRIENDLY && (HDMobBase(a) ? HDMobBase(a).bodydamage < a.SpawnHealth() * 1.2 : true))
						{
							for (int i = 0; i < 2; ++i)
							{
								a.A_SpawnParticle(partCol, 0, 25, random(2, 5), 0, frandom(-a.Radius, a.Radius), frandom(-a.Radius, a.Radius), frandom(0, a.Height), 0, 0, random(3, 6));
							}

							TargetList.Push(a);
							HitThingCount = TargetList.Size();
							continue;
						}

						if (Iterator.thing is 'HDPlayerPawn')
						{
							PlayerList.Push(HDPlayerPawn(Iterator.thing));
						}

						Name FollowerCls = 'HDFollower';
						if (Iterator.thing is FollowerCls)
						{
							FollowerList.Push(HDMobBase(Iterator.thing));
						}
					}

					// [Ace] Fire, incap, and regeneration.
					for (int i = 0; i < PlayerList.Size(); ++i)
					{
						let plr = PlayerList[i];
						plr.A_GiveInventory("HDFireDouse", 20);
						if (cubeLevel >= 1)
						{
							if (plr.incaptimer > 0)
							{
								plr.incaptimer = max(plr.incaptimer - cubeLevel, 0);
							}
							bool HasBlues = plr.regenblues > 0;
							if (plr.Health < plr.MaxHealth() && level.time % int(175 - 23.34 * (cubeLevel - 1) - (HasBlues ? 35 : 0)) == 0)
							{
								if (HasBlues)
								{
									plr.regenblues--;
								}
								plr.GiveBody(3);
								A_GainExperience(1);
							}
						}
					}

					for (int i = 0; i < FollowerList.Size(); ++i)
					{
						let flw = FollowerList[i];
						if (cubeLevel >= 1)
						{
							if (flw.stunned > 0)
							{
								flw.stunned = max(flw.stunned - cubeLevel, 0);
							}
							if (flw.Health < flw.SpawnHealth() && level.time % int(175 - 23.34 * (cubeLevel - 1)) == 0)
							{
								flw.bodydamage = max(0, flw.bodydamage - 3);
								flw.GiveBody(3);
							}
						}
					}

					// [Ace] Attack stuff.
					if (HitThingCount > 0)
					{
						if (++invoker.ShootTicker >= 35 - 5 * cubeLevel)
						{
							invoker.ShootTicker = 0;
							invoker.WeaponStatus[SCProp_Frag]--;
							if (invoker.WeaponStatus[SCProp_Frag] < MinFrag)
							{
								invoker.HasAnnounced[0] = false;
							}
							if (invoker.WeaponStatus[SCProp_Frag] < invoker.GetMaxFrag())
							{
								invoker.MaxFragTicker = 0;
								invoker.HasAnnounced[1] = false;
							}

							for (int i = 0; i < HitThingCount; ++i)
							{
								if (TargetList[i])
								{
									TargetList[i].DamageMobj(invoker, invoker.master, 150 + 25 * cubeLevel, 'Holy', DMG_THRUSTLESS);
									for (int j = 0; j < 80; ++j)
									{
										TargetList[i].A_SpawnParticle(partCol, SPF_RELATIVE, random(35, 70), random(4, 8), random(0, 359), frandom(0, TargetList[i].Radius), 0, frandom(0, TargetList[i].height), frandom(0, 1), 0, frandom(0, 3));
									}
									A_GainExperience(1); // [Ace] Per enemy hit.
								}
							}

							for (int i = 0; i < PlayerList.Size(); ++i)
							{
								let plr = PlayerList[i];
								bool HasTome = AceCore.CheckForItem(plr, "HDArcanumTome");
								int RegenAmount = (HasTome ? 2 : 1) * cubeLevel;

								let Battery = HDBattery(plr.FindInventory("HDBattery"));
								if (Battery)
								{
									int Index = AceCore.GetHighestBattery(Battery, Battery.MaxPerUnit);
									if (Index > -1)
									{
										Battery.Mags[Index] = min(Battery.Mags[Index] + HitThingCount + int(HasTome), Battery.MaxPerUnit);
									}
									else // [Ace] Batteries were full.
									{
										plr.regenblues += RegenAmount * HitThingCount;
									}
								}
								else
								{
									plr.regenblues += RegenAmount * HitThingCount;
								}
							}
						}
					}
					else
					{
						invoker.ShootTicker = 0;
					}
				}
			}
			Loop;
		Select:
			TNT1 A 0 A_AddOffset(100);
			Goto Super::Select;
		Ready:
			TNT1 A 1
			{
				if (PressingUser3())
				{
					A_MagManager("PickupManager");
					return;
				}

				int off = invoker.WeaponStatus[SCProp_UseOffset];
				if (off > 0)
				{
					invoker.WeaponStatus[SCProp_UseOffset] = off * 2 / 3;
				}

				if (PressingFire() || PressingAltfire())
				{
					SetWeaponState("Lower");
					return;
				}

				A_WeaponReady(WRF_ALLOWUSER3 | WRF_NOFIRE);
			}
			Goto ReadyEnd;
		Lower:
			TNT1 AA 1 A_AddOffset(6);
			TNT1 AAAA 1 A_AddOffset(18);
			TNT1 AAAAA 1 A_AddOffset(36);
			TNT1 A 0 A_JumpIf(!PressingFire() && !PressingAltfire(), "Ready");
			TNT1 A 1
			{
				if (invoker.WeaponStatus[SCProp_Frag] < MinFrag)
				{
					SetWeaponState("Nope");
					return;
				}

				if (PressingFire() || PressingAltfire())
				{
					if (PressingFiremode() && CountInv("SpiritualArmour") < min(3, invoker.WeaponStatus[SCProp_CubeLevel]) && invoker.WeaponStatus[SCProp_Frag] >= 20)
					{
						invoker.WeaponStatus[SCProp_Frag] -= 20;
						if (invoker.WeaponStatus[SCProp_Frag] < MinFrag)
						{
							invoker.HasAnnounced[0] = false;
						}

						let PlayerIterator = BlockThingsIterator.Create(self, MaxRange);
						while (PlayerIterator.Next())
						{
							let SpiritTarget = HDPlayerPawn(PlayerIterator.thing);
							if (SpiritTarget && (SpiritTarget == self || CheckSight(SpiritTarget)))
							{
								for (int i = 0; i < 360; ++i)
								{
									if (!random(0, 2))
									{
										SpiritTarget.A_SpawnParticle("44FF44", SPF_RELATIVE, random(35, 70), random(2, 4), i, random(8, 42), 0, frandom(0, SpiritTarget.height), 0, 0, frandom(0.5, 3), 0, 0, frandom(-0.05, 0));
									}
								}
								SpiritTarget.A_GiveInventory("SpiritualArmour", 1);
								A_GainExperience(10);
							}
						}
						
						A_StartSound("SC/Activate", CHAN_WEAPON, volume: 0.3);
						if (hdsc_archermode)
						{
							A_PlayArcherSound(self, "Praise");
						}
						SetWeaponState("Nope");
						return;
					}
					A_DeployCube(PressingAltfire(), false);
				}
			}
			Wait;
	}
}

class CubeDestination : Actor
{
	Default
	{
		+NOINTERACTION
	}

	States
	{
		Spawn:
			TNT1 A 1
			{
				if (master && master.Health > 0)
				{
					Warp(master, master.radius + 10, -(master.radius + 10), master.height + 4, flags: WARPF_NOCHECKPOSITION);
				}
			}
			Loop;
	}
}
